
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

module 9
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ex 01

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


BitcoinExchange::BitcoinExchange()
{
}

Version 2:

cpp

BitcoinExchange::BitcoinExchange() : _database()
{
}

Explication des deux versions :

    Version 1 (BitcoinExchange::BitcoinExchange() {}) :
        Ici, le constructeur par défaut est utilisé. Le corps du constructeur est vide, et les membres de la classe (comme _database) sont initialisés avec leurs constructeurs par défaut avant l'exécution du corps du constructeur. Pour les types de données intégrés (comme int, float, etc.), ces membres ne sont pas initialisés automatiquement, ce qui pourrait causer des comportements indéterminés si vous ne les initialisez pas explicitement.

    Version 2 (BitcoinExchange::BitcoinExchange() : _database() {}) :
        Cette version utilise une liste d'initialisation pour initialiser explicitement _database. Dans ce cas, _database est initialisé par son constructeur par défaut avant que le corps du constructeur soit exécuté. Si _database est un conteneur standard de la bibliothèque C++ (comme std::map), il sera correctement initialisé par son constructeur par défaut, ce qui est le comportement souhaité.

Est-ce un oubli ?

    Si _database est un type qui nécessite une initialisation particulière, alors ne pas utiliser de liste d'initialisation dans la première version peut être un oubli. Dans la plupart des cas, pour les types de données complexes (comme std::map, std::vector, etc.), il est préférable d'utiliser une liste d'initialisation pour garantir que les membres sont initialisés correctement.

    En résumé : Si vous avez des membres de classe qui nécessitent une initialisation spécifique ou qui ont des constructeurs par défaut, la deuxième version est plus explicite et peut prévenir des erreurs potentielles. Cependant, si _database est un type qui s'initialise correctement par défaut (comme un conteneur standard), la première version pourrait aussi fonctionner, mais elle est moins claire et explicite.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ex02
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

After popping 8 and 9, and performing the multiplication 8 * 9 = 72, you push 72 onto the stack:

    Stack before the push: [] (since you popped 8 and 9).
    After pushing 72, the stack becomes [72].

Next, 9 is pushed onto the stack:

    Stack before the push: [72].
    After pushing 9, the stack becomes [72, 9].

n the Reverse Polish Notation (RPN) process, values are pushed onto the stack, and when an operator is encountered, the top two values are popped off the stack to perform the operation.

Let’s go through your scenario to clarify what happens with push and pop operations.
Expression: 8 9 * 9 - 9 - 9 - 4 - 1 +

    8: Push onto the stack.
        Stack: [8]

    9: Push onto the stack.
        Stack: [8, 9]

    *: Pop the top two values (9 and 8), multiply them, and push the result (72) back onto the stack.
        Calculation: 8 * 9 = 72
        Stack: [72]

    9: Push onto the stack.
        Stack: [72, 9]

    -: Pop the top two values (9 and 72), subtract them (72 - 9), and push the result (63) back onto the stack.
        Calculation: 72 - 9 = 63
        Stack: [63]

    9: Push onto the stack.
        Stack: [63, 9]

    -: Pop the top two values (9 and 63), subtract them (63 - 9), and push the result (54) back onto the stack.
        Calculation: 63 - 9 = 54
        Stack: [54]

    9: Push onto the stack.
        Stack: [54, 9]

    -: Pop the top two values (9 and 54), subtract them (54 - 9), and push the result (45) back onto the stack.
        Calculation: 54 - 9 = 45
        Stack: [45]

    4: Push onto the stack.
        Stack: [45, 4]

    -: Pop the top two values (4 and 45), subtract them (45 - 4), and push the result (41) back onto the stack.
        Calculation: 45 - 4 = 41
        Stack: [41]

    1: Push onto the stack.
        Stack: [41, 1]

    +: Pop the top two values (1 and 41), add them (41 + 1), and push the result (42) back onto the stack.
        Calculation: 41 + 1 = 42
        Stack: [42]

Final Result: 42

So yes, 72 becomes val1 and 9 becomes val2 when you perform the subtraction (72 - 9). This behavior is correct since in RPN, the operator applies to the two most recent values on the stack, which means val2 (popped second) is the first operand and val1 (popped first) is the second operand.

The values are always popped in reverse order (LIFO—last in, first out):

    First 9 is popped (this becomes val2).
    Then 72 is popped (this becomes val1).

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ex03
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

init dans le constructeur : pk on passe par strtoul.

The end pointer in the context of strtol or strtoul is used to determine where the conversion stopped in the input string. Here’s a breakdown of what happens during the conversion:

    Input String: Suppose you have an input string like "123abc".

    Conversion with strtol or strtoul:
        When you call strtol(argv[i], &end, 10), the function attempts to convert the initial part of the string to a long integer.
        After the conversion, end will point to the first character in the string that was not converted.