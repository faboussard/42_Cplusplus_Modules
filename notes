
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

module 9
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ex 01

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


BitcoinExchange::BitcoinExchange()
{
}

Version 2:

cpp

BitcoinExchange::BitcoinExchange() : _database()
{
}

Explication des deux versions :

    Version 1 (BitcoinExchange::BitcoinExchange() {}) :
        Ici, le constructeur par défaut est utilisé. Le corps du constructeur est vide, et les membres de la classe (comme _database) sont initialisés avec leurs constructeurs par défaut avant l'exécution du corps du constructeur. Pour les types de données intégrés (comme int, float, etc.), ces membres ne sont pas initialisés automatiquement, ce qui pourrait causer des comportements indéterminés si vous ne les initialisez pas explicitement.

    Version 2 (BitcoinExchange::BitcoinExchange() : _database() {}) :
        Cette version utilise une liste d'initialisation pour initialiser explicitement _database. Dans ce cas, _database est initialisé par son constructeur par défaut avant que le corps du constructeur soit exécuté. Si _database est un conteneur standard de la bibliothèque C++ (comme std::map), il sera correctement initialisé par son constructeur par défaut, ce qui est le comportement souhaité.

Est-ce un oubli ?

    Si _database est un type qui nécessite une initialisation particulière, alors ne pas utiliser de liste d'initialisation dans la première version peut être un oubli. Dans la plupart des cas, pour les types de données complexes (comme std::map, std::vector, etc.), il est préférable d'utiliser une liste d'initialisation pour garantir que les membres sont initialisés correctement.

    En résumé : Si vous avez des membres de classe qui nécessitent une initialisation spécifique ou qui ont des constructeurs par défaut, la deuxième version est plus explicite et peut prévenir des erreurs potentielles. Cependant, si _database est un type qui s'initialise correctement par défaut (comme un conteneur standard), la première version pourrait aussi fonctionner, mais elle est moins claire et explicite.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ex02
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

After popping 8 and 9, and performing the multiplication 8 * 9 = 72, you push 72 onto the stack:

    Stack before the push: [] (since you popped 8 and 9).
    After pushing 72, the stack becomes [72].

Next, 9 is pushed onto the stack:

    Stack before the push: [72].
    After pushing 9, the stack becomes [72, 9].

n the Reverse Polish Notation (RPN) process, values are pushed onto the stack, and when an operator is encountered, the top two values are popped off the stack to perform the operation.

Let’s go through your scenario to clarify what happens with push and pop operations.
Expression: 8 9 * 9 - 9 - 9 - 4 - 1 +

    8: Push onto the stack.
        Stack: [8]

    9: Push onto the stack.
        Stack: [8, 9]

    *: Pop the top two values (9 and 8), multiply them, and push the result (72) back onto the stack.
        Calculation: 8 * 9 = 72
        Stack: [72]

    9: Push onto the stack.
        Stack: [72, 9]

    -: Pop the top two values (9 and 72), subtract them (72 - 9), and push the result (63) back onto the stack.
        Calculation: 72 - 9 = 63
        Stack: [63]

    9: Push onto the stack.
        Stack: [63, 9]

    -: Pop the top two values (9 and 63), subtract them (63 - 9), and push the result (54) back onto the stack.
        Calculation: 63 - 9 = 54
        Stack: [54]

    9: Push onto the stack.
        Stack: [54, 9]

    -: Pop the top two values (9 and 54), subtract them (54 - 9), and push the result (45) back onto the stack.
        Calculation: 54 - 9 = 45
        Stack: [45]

    4: Push onto the stack.
        Stack: [45, 4]

    -: Pop the top two values (4 and 45), subtract them (45 - 4), and push the result (41) back onto the stack.
        Calculation: 45 - 4 = 41
        Stack: [41]

    1: Push onto the stack.
        Stack: [41, 1]

    +: Pop the top two values (1 and 41), add them (41 + 1), and push the result (42) back onto the stack.
        Calculation: 41 + 1 = 42
        Stack: [42]

Final Result: 42

So yes, 72 becomes val1 and 9 becomes val2 when you perform the subtraction (72 - 9). This behavior is correct since in RPN, the operator applies to the two most recent values on the stack, which means val2 (popped second) is the first operand and val1 (popped first) is the second operand.

The values are always popped in reverse order (LIFO—last in, first out):

    First 9 is popped (this becomes val2).
    Then 72 is popped (this becomes val1).

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

module 8
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

SPAN EX 01

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    unsigned int shortest = std::numeric_limits<unsigned int>::max();

does the following:

    std::numeric_limits<unsigned int>::max():
        This part of the code retrieves the maximum possible value that an unsigned int type can hold.
        std::numeric_limits is a template class in the C++ Standard Library that provides information about the properties of fundamental data types.
        max() is a static member function of std::numeric_limits<T> that returns the maximum finite value representable by the type T. For unsigned int, this is typically 4294967295 on most systems (which is 2^32 - 1).


    shortest = std::numeric_limits<unsigned int>::max();:
        This initializes the shortest variable to the maximum possible value of an unsigned int.

Why Do This?

Setting shortest to the maximum possible value of unsigned int is often done as an initialization step in algorithms that need to find the minimum value in a sequence of numbers.


EX 02 MUTANT STACK
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	typedef typename Container::iterator iterator;
	typedef typename Container::const_iterator const_iterator;

	template< typename T, typename Container = std::deque<T> >
    class MutantStack : public std::stack<T, Container>

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Module 8 :

<algorithm>
Standard Template Library: Algorithms
The header <algorithm> defines a collection of functions especially designed to be used on ranges of elements.

A range is any sequence of objects that can be accessed through iterators or pointers, such as an array or an instance of some of the STL containers. Notice though, that algorithms operate through iterators directly on the values, not affecting in any way the structure of any possible container (it never affects the size or storage allocation of the container).

Pourquoi l'opérateur * est utilisé ?
    • *it : Lorsque vous utilisez l'opérateur * sur un itérateur, vous déréférencez cet itérateur, c'est-à-dire que vous accédez à l'élément du conteneur vers lequel l'itérateur pointe. Par exemple, si it est un itérateur qui pointe vers un élément d'un std::vector<int>, alors *it vous donne cet élément int.
    • *(it + 1) : Cette expression signifie "l'élément suivant dans le conteneur". it + 1 crée un nouvel itérateur qui pointe vers l'élément suivant, et * déréférence cet itérateur pour accéder à la valeur de cet élément
Understanding std::deque and its c Member
std::deque (double-ended queue) is a standard container in C++ that allows fast insertions and deletions at both the front and the back of the container. It's a more flexible alternative to std::vector when you need this kind of flexibility. Here's a brief overview:
    • Characteristics of std::deque:
        ◦ Dynamic Size: It can grow and shrink dynamically as elements are added or removed.
        ◦ Fast Access: Provides constant time complexity for accessing elements by index.
        ◦ Fast Insertions/Deletions: Efficient at adding or removing elements from both ends.
    • c Member in std::stack:
        ◦ In std::stack, the container is a private member called c. This container is used to hold the elements of the stack.
        ◦ For std::stack, the default underlying container is std::deque. The container c is not directly accessible from outside the class. However, you can use it via MutantStack, which inherits from std::stack and provides access to it through its iterators.
Example of std::deque
Here’s a simple example to illustrate the use of std::deque:
cpp
Copy code
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq;

    // Add elements
    deq.push_back(1);
    deq.push_back(2);
    deq.push_front(0);

    // Access elements
    std::cout << "Deque elements: ";
    for (auto it = deq.begin(); it != deq.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
Const and Non-Const Iterators
Iterators are objects that provide a way to access elements in a container sequentially. They come in two flavors:
    1. Const Iterators:
        ◦ They provide read-only access to the elements of the container.
        ◦ They do not allow modification of the elements they point to.
       Example Usage:
       cpp
       Copy code
       const std::deque<int> deq = {1, 2, 3, 4, 5};
       for (std::deque<int>::const_iterator it = deq.begin(); it != deq.end(); ++it) {
           std::cout << *it << " "; // Read-only access
       }
    2. Non-Const Iterators:
        ◦ They provide read and write access to the elements of the container.
        ◦ They allow modification of the elements they point to.
       Example Usage:
       cpp
       Copy code
       std::deque<int> deq = {1, 2, 3, 4, 5};
       for (std::deque<int>::iterator it = deq.begin(); it != deq.end(); ++it) {
           *it += 1; // Modifying elements
       }
When to Use Non-Const Iterators
Non-const iterators are useful when you need to modify the elements of the container. For example, if you want to increment every element in a container, you would use a non-const iterator:
cpp
Copy code
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3, 4, 5};

    // Increment each element
    for (std::deque<int>::iterator it = deq.begin(); it != deq.end(); ++it) {
        *it += 10; // Modify the element
    }

    // Print the updated elements
    std::cout << "Updated deque elements: ";
    for (auto it = deq.begin(); it != deq.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
In this example, using a non-const iterator allows modification of each element in the std::deque.
When to Use std::vector:
    • When you need random access to elements.
    • When you mostly add or remove elements at the end of the container.
    • When you require contiguous memory for better cache locality.
