module 6 :

static cast, reinterpret cast, dynamic cast


ex01

faire comme un json avec le serializer (reinterpret en unintptr : un long pointeur qui peut stocker toute ladresse et en positif car les adresses sont positives


ex02

dynamic_cast : Permet de convertir un pointeur ou une référence d'un type de base en un type dérivé (ou vice versa) en toute sécurité. Si la conversion échoue, il renvoie un pointeur nul (pour les pointeurs) ou lance une exception std::bad_cast (pour les références).

dynamic_cast is a feature in C++ that provides a way to safely and correctly convert pointers or references to objects in an inheritance hierarchy. Its primary purpose is to perform type-safe downcasting, which means casting a pointer or reference from a base class to a derived class. It is particularly useful in situations involving polymorphism where you don't know the exact type of the object at compile time but need to determine or use the derived type at runtime.
static_cast : Peut également être utilisé pour la conversion, mais il ne vérifie pas la validité de la conversion à l'exécution. Il est donc moins sûr que dynamic_cast lorsqu'il s'agit de polymorphisme.

L'adresse de c est également l'adresse de l'objet Base et A qu'il contient.

Why Use dynamic_cast?
Type Safety:

dynamic_cast checks at runtime whether the conversion is valid, ensuring that you don't accidentally perform an invalid cast, which could lead to undefined behavior or crashes.
If the cast is invalid (e.g., the object isn't of the derived type you're trying to cast to), dynamic_cast returns nullptr for pointers or throws a std::bad_cast exception for references, allowing your program to handle the situation gracefully.
Working with Polymorphic Classes:

When dealing with polymorphism (using base class pointers to refer to objects of derived classes), you might need to know the actual type of the object at runtime. dynamic_cast enables you to safely determine this type.
Concrete Applications of dynamic_cast:
GUI Frameworks:

In GUI frameworks, widgets like buttons, labels, and sliders might all inherit from a common base class like Widget. If you have a collection of Widget* pointers, dynamic_cast can help determine the actual type of each widget at runtime (e.g., Button*, Label*) and handle them accordingly.
Game Development:

In games, different types of entities (e.g., Player, Enemy, NPC) might inherit from a common Entity base class. A game engine might have a list of Entity* pointers. When iterating through this list, dynamic_cast can be used to check if an entity is a Player, Enemy, or NPC, and then apply specific logic based on the type.
Plugin Architectures:

Applications that support plugins might use a base Plugin class that all plugins derive from. When the application loads a plugin, it might need to determine the specific type of plugin (e.g., AudioPlugin, VideoPlugin) to interact with it in a type-specific manner. dynamic_cast enables this discovery at runtime.
Type-Safe Collections:

Suppose you have a heterogeneous collection of objects (e.g., a collection of pointers to different derived types of a base class). dynamic_cast can be used to iterate over this collection and perform type-specific operations depending on the actual type of each object.
RTTI (Run-Time Type Information) Operations:

dynamic_cast relies on RTTI to safely cast types. In scenarios where you are performing operations that depend on the actual type of an object rather than just the interface provided by its base class, dynamic_cast provides a way to query and use this type information at runtime.

class Shape {
public:
    virtual ~Shape() {}
    virtual void draw() = 0;
};

class Circle : public Shape {
public:
    void draw() override { std::cout << "Drawing Circle\n"; }
    void radius() { std::cout << "Radius of Circle\n"; }
};

class Square : public Shape {
public:
    void draw() override { std::cout << "Drawing Square\n"; }
    void sideLength() { std::cout << "Side length of Square\n"; }
};

void identifyAndDraw(Shape* shape) {
    if (Circle* circle = dynamic_cast<Circle*>(shape)) {
        circle->draw();
        circle->radius();
    } else if (Square* square = dynamic_cast<Square*>(shape)) {
        square->draw();
        square->sideLength();
    } else {
        std::cout << "Unknown Shape\n";
    }
}

dynamic_cast is a powerful tool in C++ for type-safe downcasting in polymorphic hierarchies. It's particularly useful in scenarios where you need to determine the exact type of an object at runtime and perform operations based on that type. However, its use should be considered carefully, and in many cases, good design can reduce or eliminate the need for such casting.